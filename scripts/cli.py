# scripts/cli.py
"""Central CLI for Assembled Trading AI Backend.

This script provides a unified command-line interface for the most important backend operations:
- run_daily: Daily EOD pipeline
- run_backtest: Strategy backtest
- run_phase4_tests: Phase-4 test suite
- info: Show project information

Usage:
    python scripts/cli.py run_daily --freq 1d
    python scripts/cli.py run_backtest --freq 1d --universe watchlist.txt
    python scripts/cli.py run_phase4_tests
    python scripts/cli.py info
    python scripts/cli.py --version
"""
from __future__ import annotations

import argparse
import subprocess
import sys
from pathlib import Path

import pandas as pd

# Import core modules
ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT))

from src.assembled_core.logging_utils import setup_logging

logger = setup_logging(level="INFO")

# Project version (from pyproject.toml / __init__.py)
__version__ = "0.0.1"


def get_git_branch() -> str | None:
    """Try to get current git branch.
    
    Returns:
        Branch name if git is available, None otherwise
    """
    try:
        result = subprocess.run(
            ["git", "branch", "--show-current"],
            cwd=str(ROOT),
            capture_output=True,
            text=True,
            check=False,
            timeout=2
        )
        if result.returncode == 0 and result.stdout.strip():
            return result.stdout.strip()
    except (subprocess.TimeoutExpired, FileNotFoundError, Exception):
        pass
    return None


def print_version() -> None:
    """Print version and project information."""
    branch = get_git_branch()
    print("Assembled Trading AI - Central CLI")
    print(f"Version: {__version__}")
    if branch:
        print(f"Git Branch: {branch}")
    print("Status: Phase-4/Phase-6 ready")
    print(f"Python: {sys.version.split()[0]}")


def info_subcommand(args: argparse.Namespace) -> int:
    """Show project information subcommand.
    
    Args:
        args: Parsed command-line arguments (unused)
        
    Returns:
        Exit code (always 0)
    """
    print("=" * 60)
    print("Assembled Trading AI - Project Information")
    print("=" * 60)
    print()
    print("Main Subcommands:")
    print("  run_daily          - Run daily EOD pipeline (execute, backtest, portfolio, QA)")
    print("  run_backtest       - Run strategy backtest with portfolio-level engine")
    print("  run_phase4_tests   - Run Phase-4 regression test suite (~13s, 110 tests)")
    print("  info               - Show this information")
    print()
    print("Documentation:")
    print("  - Backend Architecture: docs/ARCHITECTURE_BACKEND.md")
    print("  - Legacy Overview: docs/LEGACY_OVERVIEW.md")
    print("  - Legacy Mapping: docs/LEGACY_TO_CORE_MAPPING.md")
    print("  - PowerShell Wrappers: docs/POWERSHELL_WRAPPERS.md")
    print("  - Testing Commands: docs/TESTING_COMMANDS.md")
    print()
    print("Examples:")
    print("  python scripts/cli.py run_daily --freq 1d")
    print("  python scripts/cli.py run_backtest --freq 1d --universe watchlist.txt --generate-report")
    print("  python scripts/cli.py run_phase4_tests --verbose --durations 5")
    print()
    print("For detailed help on a subcommand:")
    print("  python scripts/cli.py <subcommand> --help")
    print()
    return 0


def run_daily_subcommand(args: argparse.Namespace) -> int:
    """Run daily EOD pipeline subcommand.
    
    Args:
        args: Parsed command-line arguments for run_daily
        
    Returns:
        Exit code (0 for success, 1 for failure)
    
    Note:
        Orders generated by this command are currently written to SAFE-CSV files.
        If orders are later routed to the Paper-Trading-API (Phase 10), the source
        field should be set to "CLI_EOD" to identify the origin.
    """
    logger.info("=" * 60)
    logger.info("EOD Pipeline (run_daily)")
    logger.info("=" * 60)
    
    # Import here to avoid circular imports
    from scripts.run_eod_pipeline import run_eod_from_args
    
    try:
        run_eod_from_args(args)
        return 0
    except RuntimeError:
        # Expected error from run_eod_from_args when pipeline fails
        return 1
    except Exception as e:
        logger.error(f"EOD pipeline failed: {e}", exc_info=True)
        return 1


def build_ml_dataset_subcommand(args: argparse.Namespace) -> int:
    """Build ML dataset from backtest results subcommand.
    
    Args:
        args: Parsed command-line arguments for build_ml_dataset
        
    Returns:
        Exit code (0 for success, 1 for failure)
    """
    logger.info("=" * 60)
    logger.info("ML Dataset Builder (build_ml_dataset)")
    logger.info("=" * 60)
    
    try:
        import pandas as pd
        from src.assembled_core.config import OUTPUT_DIR
        from src.assembled_core.qa.dataset_builder import build_ml_dataset_from_backtest, save_ml_dataset
        
        # Set output path
        if args.out:
            output_path = Path(args.out)
        else:
            output_dir = OUTPUT_DIR / "ml_datasets"
            output_dir.mkdir(parents=True, exist_ok=True)
            output_path = output_dir / f"{args.strategy}_{args.freq}.parquet"
        
        logger.info(f"Strategy: {args.strategy}")
        logger.info(f"Frequency: {args.freq}")
        logger.info(f"Label Horizon: {args.label_horizon_days} days")
        logger.info(f"Success Threshold: {args.success_threshold:.2%}")
        logger.info(f"Output Path: {output_path}")
        
        # Run backtest and get prices_with_features and trades
        logger.info("")
        logger.info("Running backtest...")
        prices_with_features, trades = _run_backtest_for_ml_dataset(
            strategy=args.strategy,
            freq=args.freq,
            price_file=args.price_file,
            universe=args.universe,
            start_capital=args.start_capital,
            with_costs=args.with_costs,
            output_dir=OUTPUT_DIR
        )
        
        if prices_with_features.empty:
            logger.error("No price data with features available")
            return 1
        
        if trades.empty:
            logger.error("No trades generated from backtest")
            return 1
        
        logger.info(f"Prices with features: {len(prices_with_features)} rows, {prices_with_features['symbol'].nunique()} symbols")
        logger.info(f"Trades: {len(trades)} trades")
        
        # Build ML dataset
        logger.info("")
        logger.info("Building ML dataset...")
        ml_dataset = build_ml_dataset_from_backtest(
            prices_with_features=prices_with_features,
            trades=trades,
            label_horizon_days=args.label_horizon_days,
            success_threshold=args.success_threshold,
            feature_prefixes=("ta_", "insider_", "congress_", "shipping_", "news_")
        )
        
        if ml_dataset.empty:
            logger.error("ML dataset is empty")
            return 1
        
        logger.info(f"ML dataset built: {len(ml_dataset)} records, {len(ml_dataset.columns)} columns")
        
        # Count labels
        if "label" in ml_dataset.columns:
            label_counts = ml_dataset["label"].value_counts()
            logger.info(f"Label distribution: {dict(label_counts)}")
        
        # Save dataset
        logger.info("")
        logger.info("Saving ML dataset...")
        save_ml_dataset(ml_dataset, output_path)
        
        logger.info("")
        logger.info("=" * 60)
        logger.info("ML Dataset Build Complete")
        logger.info("=" * 60)
        logger.info(f"Output: {output_path}")
        logger.info(f"Records: {len(ml_dataset)}")
        logger.info(f"Features: {len([c for c in ml_dataset.columns if c not in ['label', 'open_time', 'symbol', 'open_price', 'close_time', 'pnl_pct', 'horizon_days']])}")
        logger.info("=" * 60)
        
        return 0
    
    except FileNotFoundError as e:
        logger.error(f"File not found: {e}")
        return 1
    except ValueError as e:
        logger.error(f"Invalid input: {e}")
        return 1
    except KeyboardInterrupt:
        logger.warning("Interrupted by user")
        return 1
    except Exception as e:
        logger.error(f"Unexpected error: {e}", exc_info=True)
        return 1


def run_backtest_subcommand(args: argparse.Namespace) -> int:
    """Run strategy backtest subcommand.
    
    Args:
        args: Parsed command-line arguments for run_backtest
        
    Returns:
        Exit code (0 for success, 1 for failure)
    
    Note:
        Orders generated by this command are currently written to SAFE-CSV files.
        If orders are later routed to the Paper-Trading-API (Phase 10), the source
        field should be set to "CLI_BACKTEST" to identify the origin.
    """
    logger.info("=" * 60)
    logger.info("Strategy Backtest (run_backtest)")
    logger.info("=" * 60)
    
    # Import here to avoid circular imports
    from scripts.run_backtest_strategy import run_backtest_from_args
    
    try:
        return run_backtest_from_args(args)
    except Exception as e:
        logger.error(f"Backtest failed: {e}", exc_info=True)
        return 1


def _run_backtest_for_ml_dataset(
    strategy: str,
    freq: str,
    price_file: Path | None = None,
    universe: Path | None = None,
    start_capital: float = 10000.0,
    with_costs: bool = True,
    commission_bps: float | None = None,
    spread_w: float | None = None,
    impact_w: float | None = None,
    output_dir: Path | None = None,
) -> tuple[pd.DataFrame, pd.DataFrame]:
    """Run backtest and return prices_with_features and trades for ML dataset building.
    
    This is a helper function that runs a backtest and extracts the prices_with_features
    and trades DataFrames needed for building ML datasets.
    
    Args:
        strategy: Strategy name ("trend_baseline" or "event_insider_shipping")
        freq: Trading frequency ("1d" or "5min")
        price_file: Optional explicit path to price file
        universe: Optional path to universe file
        start_capital: Starting capital
        with_costs: Whether to include transaction costs
        commission_bps: Optional commission override
        spread_w: Optional spread weight override
        impact_w: Optional market impact weight override
        output_dir: Optional output directory for price data loading
    
    Returns:
        Tuple of (prices_with_features, trades) DataFrames
    
    Raises:
        ValueError: If strategy is unknown or data loading fails
        FileNotFoundError: If price file or universe file not found
    """
    import pandas as pd
    from src.assembled_core.config import OUTPUT_DIR
    from src.assembled_core.costs import CostModel, get_default_cost_model
    from src.assembled_core.data.prices_ingest import load_eod_prices, load_eod_prices_for_universe
    from src.assembled_core.ema_config import get_default_ema_config
    from src.assembled_core.qa.backtest_engine import run_portfolio_backtest
    from scripts.run_backtest_strategy import (
        create_trend_baseline_signal_fn,
        create_position_sizing_fn,
        create_event_insider_shipping_signal_fn,
        create_event_position_sizing_fn,
        get_cost_model,
    )
    
    # Set output directory
    if output_dir is None:
        output_dir = OUTPUT_DIR
    
    # Load price data
    if price_file:
        logger.info(f"Loading prices from explicit file: {price_file}")
        prices = load_eod_prices(price_file=price_file, freq=freq)
    elif universe:
        logger.info(f"Loading prices for universe: {universe}")
        prices = load_eod_prices_for_universe(
            universe_file=universe,
            data_dir=output_dir,
            freq=freq
        )
    else:
        # Default: use watchlist.txt
        logger.info("Loading prices for default universe (watchlist.txt)")
        prices = load_eod_prices_for_universe(
            universe_file=None,
            data_dir=output_dir,
            freq=freq
        )
    
    if prices.empty:
        raise ValueError("No price data loaded")
    
    logger.info(f"Loaded {len(prices)} rows for {prices['symbol'].nunique()} symbols")
    
    # Get cost model
    class CostArgs:
        def __init__(self):
            self.commission_bps = commission_bps
            self.spread_w = spread_w
            self.impact_w = impact_w
    
    cost_args = CostArgs()
    cost_model = get_cost_model(cost_args)
    
    # Build prices_with_features by computing all features
    from src.assembled_core.features.ta_features import add_all_features, add_log_returns, add_moving_averages
    
    # Add TA features
    has_ohlc = all(col in prices.columns for col in ["high", "low", "open"])
    if has_ohlc:
        prices_with_features = add_all_features(
            prices,
            ma_windows=(20, 50, 200),
            atr_window=14,
            rsi_window=14,
            include_rsi=True
        )
    else:
        prices_with_features = add_log_returns(prices.copy())
        prices_with_features = add_moving_averages(
            prices_with_features,
            windows=(20, 50, 200)
        )
    
    # Add event features if event strategy
    if strategy == "event_insider_shipping":
        from src.assembled_core.features.insider_features import add_insider_features
        from src.assembled_core.features.shipping_features import add_shipping_features
        from src.assembled_core.data.insider_ingest import load_insider_sample
        from src.assembled_core.data.shipping_routes_ingest import load_shipping_sample
        from pathlib import Path as P
        
        ROOT = P(__file__).resolve().parents[1]
        EVENT_DIR = ROOT / "data" / "sample" / "events"
        
        insider_file = EVENT_DIR / "insider_sample.parquet"
        shipping_file = EVENT_DIR / "shipping_sample.parquet"
        
        if insider_file.exists():
            insider_events = pd.read_parquet(insider_file)
            if "timestamp" in insider_events.columns:
                insider_events["timestamp"] = pd.to_datetime(insider_events["timestamp"], utc=True)
        else:
            insider_events = load_insider_sample()
        
        if shipping_file.exists():
            shipping_events = pd.read_parquet(shipping_file)
            if "timestamp" in shipping_events.columns:
                shipping_events["timestamp"] = pd.to_datetime(shipping_events["timestamp"], utc=True)
        else:
            shipping_events = load_shipping_sample()
        
        prices_with_features = add_insider_features(prices_with_features, insider_events)
        prices_with_features = add_shipping_features(prices_with_features, shipping_events)
    
    # Create signal and position sizing functions
    if strategy == "trend_baseline":
        ema_config = get_default_ema_config(freq)
        signal_fn = create_trend_baseline_signal_fn(
            ma_fast=ema_config.fast,
            ma_slow=ema_config.slow
        )
        position_sizing_fn = create_position_sizing_fn()
    elif strategy == "event_insider_shipping":
        signal_fn = create_event_insider_shipping_signal_fn()
        position_sizing_fn = create_event_position_sizing_fn()
    else:
        raise ValueError(f"Unknown strategy: {strategy}. Supported: trend_baseline, event_insider_shipping")
    
    # Run backtest to get trades
    result = run_portfolio_backtest(
        prices=prices_with_features,  # Use prices_with_features for signal generation
        signal_fn=signal_fn,
        position_sizing_fn=position_sizing_fn,
        start_capital=start_capital,
        commission_bps=cost_model.commission_bps,
        spread_w=cost_model.spread_w,
        impact_w=cost_model.impact_w,
        include_costs=with_costs,
        include_trades=True,
        include_signals=False,
        include_targets=False,
        rebalance_freq=freq,
        compute_features=False  # We already computed features above
    )
    
    if result.trades is None or result.trades.empty:
        logger.warning("No trades generated from backtest")
        trades = pd.DataFrame()
    else:
        trades = result.trades.copy()
        # Ensure trades have required columns for labeling
        if "open_time" not in trades.columns and "timestamp" in trades.columns:
            trades["open_time"] = trades["timestamp"]
        if "open_price" not in trades.columns and "price" in trades.columns:
            trades["open_price"] = trades["price"]
    
    return prices_with_features, trades


def run_phase4_tests_subcommand(args: argparse.Namespace) -> int:
    """Run Phase-4 test suite subcommand.
    
    Args:
        args: Parsed command-line arguments for run_phase4_tests
        
    Returns:
        Exit code from pytest (0 for success, non-zero for failure)
    """
    logger.info("=" * 60)
    logger.info("Phase-4 Test Suite (run_phase4_tests)")
    logger.info("=" * 60)
    
    # Build pytest command
    pytest_args = [
        sys.executable,
        "-m", "pytest",
        "-m", "phase4",
        "-q",
        "--maxfail=1",
        "--tb=short"
    ]
    
    # Remove -q if verbose is requested
    if args.verbose:
        pytest_args = [arg for arg in pytest_args if arg != "-q"]
        pytest_args.append("-vv")
    
    if args.durations:
        pytest_args.append(f"--durations={args.durations}")
    
    logger.info(f"Running: {' '.join(pytest_args[2:])}")  # Exclude python and -m pytest for cleaner log
    logger.info("")
    
    # Run pytest
    try:
        result = subprocess.run(
            pytest_args,
            cwd=str(ROOT),
            check=False  # Don't raise on non-zero exit
        )
        return result.returncode
    except Exception as e:
        logger.error(f"Failed to run pytest: {e}", exc_info=True)
        return 1


def create_parser() -> argparse.ArgumentParser:
    """Create the main argument parser with subcommands.
    
    Returns:
        Configured ArgumentParser
    """
    parser = argparse.ArgumentParser(
        description="Assembled Trading AI - Central CLI",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Run daily EOD pipeline
  python scripts/cli.py run_daily --freq 1d
  
  # Run strategy backtest
              python scripts/cli.py run_backtest --freq 1d --universe watchlist.txt --generate-report
              python scripts/cli.py run_backtest --freq 1d --strategy event_insider_shipping --generate-report
  
  # Run Phase-4 tests
  python scripts/cli.py run_phase4_tests
  
  # Run Phase-4 tests with verbose output and durations
  python scripts/cli.py run_phase4_tests --verbose --durations 5
  
  # Show project information
  python scripts/cli.py info
  
  # Show version
  python scripts/cli.py --version
        """
    )
    
    # Global --version flag
    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {__version__}",
        help="Show version and exit"
    )
    
    subparsers = parser.add_subparsers(dest="command", help="Subcommand to run", required=True)
    
    # run_daily subcommand
    daily_parser = subparsers.add_parser(
        "run_daily",
        help="Run daily EOD pipeline (execute, backtest, portfolio, QA)",
        description="Runs the full EOD pipeline: execute, backtest, portfolio simulation, and QA checks.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/cli.py run_daily --freq 1d
  python scripts/cli.py run_daily --freq 1d --universe watchlist.txt --start-capital 50000
  python scripts/cli.py run_daily --freq 5min --price-file data/sample/eod_sample.parquet
        """
    )
    daily_parser.add_argument(
        "--freq",
        type=str,
        required=True,
        choices=["1d", "5min"],
        help="Trading frequency: '1d' for daily or '5min' for 5-minute bars"
    )
    daily_parser.add_argument(
        "--universe",
        type=Path,
        default=None,
        metavar="FILE",
        help="Path to universe file (default: watchlist.txt in repo root)"
    )
    daily_parser.add_argument(
        "--price-file",
        type=str,
        default=None,
        metavar="FILE",
        help="Optional explicit path to price file (overrides default path)"
    )
    daily_parser.add_argument(
        "--start-date",
        type=str,
        default=None,
        metavar="YYYY-MM-DD",
        help="Start date for price data filtering (optional)"
    )
    daily_parser.add_argument(
        "--end-date",
        type=str,
        default=None,
        metavar="YYYY-MM-DD",
        help="End date for price data filtering (optional)"
    )
    daily_parser.add_argument(
        "--start-capital",
        type=float,
        default=10000.0,
        metavar="AMOUNT",
        help="Starting capital in USD (default: 10000.0)"
    )
    daily_parser.add_argument(
        "--skip-backtest",
        action="store_true",
        help="Skip backtest step in pipeline"
    )
    daily_parser.add_argument(
        "--skip-portfolio",
        action="store_true",
        help="Skip portfolio simulation step"
    )
    daily_parser.add_argument(
        "--skip-qa",
        action="store_true",
        help="Skip QA checks step"
    )
    daily_parser.add_argument(
        "--commission-bps",
        type=float,
        default=None,
        metavar="BPS",
        help="Commission in basis points (overrides default cost model)"
    )
    daily_parser.add_argument(
        "--spread-w",
        type=float,
        default=None,
        metavar="WEIGHT",
        help="Spread weight for cost model (overrides default)"
    )
    daily_parser.add_argument(
        "--impact-w",
        type=float,
        default=None,
        metavar="WEIGHT",
        help="Market impact weight for cost model (overrides default)"
    )
    daily_parser.add_argument(
        "--out",
        type=Path,
        default=None,
        metavar="DIR",
        help="Output directory (default: from config.OUTPUT_DIR)"
    )
    daily_parser.set_defaults(func=run_daily_subcommand)
    
    # run_backtest subcommand
    backtest_parser = subparsers.add_parser(
        "run_backtest",
        help="Run strategy backtest",
        description="Runs a strategy backtest using the portfolio-level backtest engine.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/cli.py run_backtest --freq 1d --universe watchlist.txt
  python scripts/cli.py run_backtest --freq 1d --price-file data/sample/eod_sample.parquet --generate-report
  python scripts/cli.py run_backtest --freq 5min --start-capital 50000 --no-costs
        """
    )
    backtest_parser.add_argument(
        "--freq",
        type=str,
        required=True,
        choices=["1d", "5min"],
        help="Trading frequency: '1d' for daily or '5min' for 5-minute bars"
    )
    backtest_parser.add_argument(
        "--price-file",
        type=Path,
        default=None,
        metavar="FILE",
        help="Explicit path to price file (overrides default path)"
    )
    backtest_parser.add_argument(
        "--universe",
        type=Path,
        default=None,
        metavar="FILE",
        help="Path to universe file (default: watchlist.txt in repo root)"
    )
    backtest_parser.add_argument(
        "--strategy",
        type=str,
        default="trend_baseline",
        choices=["trend_baseline", "event_insider_shipping"],
        metavar="NAME",
        help="Strategy name: 'trend_baseline' (EMA crossover) or 'event_insider_shipping' (Phase 6 event-based)"
    )
    backtest_parser.add_argument(
        "--start-capital",
        type=float,
        default=10000.0,
        metavar="AMOUNT",
        help="Starting capital in USD (default: 10000.0)"
    )
    backtest_parser.add_argument(
        "--with-costs",
        action="store_true",
        default=True,
        help="Include transaction costs in backtest (default: True)"
    )
    backtest_parser.add_argument(
        "--no-costs",
        action="store_false",
        dest="with_costs",
        help="Disable transaction costs (use cost-free simulation)"
    )
    backtest_parser.add_argument(
        "--commission-bps",
        type=float,
        default=None,
        metavar="BPS",
        help="Commission in basis points (overrides default cost model)"
    )
    backtest_parser.add_argument(
        "--spread-w",
        type=float,
        default=None,
        metavar="WEIGHT",
        help="Spread weight for cost model (overrides default)"
    )
    backtest_parser.add_argument(
        "--impact-w",
        type=float,
        default=None,
        metavar="WEIGHT",
        help="Market impact weight for cost model (overrides default)"
    )
    backtest_parser.add_argument(
        "--out",
        type=Path,
        default=None,
        metavar="DIR",
        help="Output directory (default: from config.OUTPUT_DIR)"
    )
    backtest_parser.add_argument(
        "--generate-report",
        action="store_true",
        default=False,
        help="Generate QA report after backtest"
    )
    backtest_parser.set_defaults(func=run_backtest_subcommand)
    
    # build_ml_dataset subcommand
    ml_dataset_parser = subparsers.add_parser(
        "build_ml_dataset",
        help="Build ML-ready dataset from backtest results",
        description="Runs a strategy backtest and builds an ML-ready dataset with features and labels.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=""" 
Examples:
  python scripts/cli.py build_ml_dataset --strategy trend_baseline --freq 1d
  python scripts/cli.py build_ml_dataset --strategy event_insider_shipping --freq 1d --price-file data/sample/eod_sample.parquet
  python scripts/cli.py build_ml_dataset --strategy trend_baseline --freq 1d --label-horizon-days 5 --success-threshold 0.03
        """
    )
    ml_dataset_parser.add_argument(
        "--strategy",
        type=str,
        required=True,
        choices=["trend_baseline", "event_insider_shipping"],
        metavar="NAME",
        help="Strategy name: 'trend_baseline' (EMA crossover) or 'event_insider_shipping' (Phase 6 event-based)"
    )
    ml_dataset_parser.add_argument(
        "--freq",
        type=str,
        required=True,
        choices=["1d", "5min"],
        help="Trading frequency: '1d' for daily or '5min' for 5-minute bars"
    )
    ml_dataset_parser.add_argument(
        "--price-file",
        type=Path,
        default=None,
        metavar="FILE",
        help="Explicit path to price file (overrides default path)"
    )
    ml_dataset_parser.add_argument(
        "--universe",
        type=Path,
        default=None,
        metavar="FILE",
        help="Path to universe file (default: watchlist.txt in repo root)"
    )
    ml_dataset_parser.add_argument(
        "--start-capital",
        type=float,
        default=10000.0,
        metavar="AMOUNT",
        help="Starting capital in USD (default: 10000.0)"
    )
    ml_dataset_parser.add_argument(
        "--with-costs",
        action="store_true",
        default=True,
        help="Include transaction costs in backtest (default: True)"
    )
    ml_dataset_parser.add_argument(
        "--no-costs",
        action="store_false",
        dest="with_costs",
        help="Disable transaction costs (use cost-free simulation)"
    )
    ml_dataset_parser.add_argument(
        "--label-horizon-days",
        type=int,
        default=10,
        metavar="DAYS",
        help="Number of days to look forward for P&L calculation (default: 10)"
    )
    ml_dataset_parser.add_argument(
        "--success-threshold",
        type=float,
        default=0.02,
        metavar="THRESHOLD",
        help="P&L percentage threshold for a successful trade (label=1) (default: 0.02 = 2%%)"
    )
    ml_dataset_parser.add_argument(
        "--out",
        type=Path,
        default=None,
        metavar="FILE",
        help="Output path for ML dataset (default: output/ml_datasets/<strategy>_<freq>.parquet)"
    )
    ml_dataset_parser.set_defaults(func=build_ml_dataset_subcommand)
    
    # run_phase4_tests subcommand
    tests_parser = subparsers.add_parser(
        "run_phase4_tests",
        help="Run Phase-4 test suite",
        description="Runs the Phase-4 regression test suite (~13s, 110 tests).",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/cli.py run_phase4_tests
  python scripts/cli.py run_phase4_tests --verbose
  python scripts/cli.py run_phase4_tests --durations 5
  python scripts/cli.py run_phase4_tests --verbose --durations 10
        """
    )
    tests_parser.add_argument(
        "--durations",
        type=int,
        default=None,
        metavar="N",
        help="Show N slowest tests (e.g., 5 for --durations=5)"
    )
    tests_parser.add_argument(
        "--verbose",
        action="store_true",
        default=False,
        help="Show verbose test output (-vv instead of -q)"
    )
    tests_parser.set_defaults(func=run_phase4_tests_subcommand)
    
    # info subcommand
    info_parser = subparsers.add_parser(
        "info",
        help="Show project information",
        description="Shows project information, available subcommands, and documentation links."
    )
    info_parser.set_defaults(func=info_subcommand)
    
    return parser


def main() -> int:
    """Main entry point for central CLI.
    
    Returns:
        Exit code (0 for success, non-zero for failure)
    """
    parser = create_parser()
    args = parser.parse_args()
    
    # Handle --version flag (before subcommand routing)
    if hasattr(args, "version") and args.version:
        print_version()
        return 0
    
    # Route to appropriate subcommand
    if hasattr(args, "func"):
        return args.func(args)
    else:
        parser.error("No subcommand specified. Use --help for usage.")


if __name__ == "__main__":
    sys.exit(main())
