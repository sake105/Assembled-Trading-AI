#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Sprint 9 â€“ PF Backtest & Cost-Adjusted Performance
Reads:
- output/orders.csv (from Sprint 8 Execution)
- output/features/regime_<freq>.parquet (for price series)
Writes:
- output/performance_report.md
- output/equity_curve_<freq>.csv
- logs/sprint9_backtest.log
"""
from __future__ import annotations
import argparse
import numpy as np
import pandas as pd
from dataclasses import dataclass
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
OUT = ROOT / "output"
FEAT = OUT / "features"
LOGS = ROOT / "logs"
OUT.mkdir(parents=True, exist_ok=True)
LOGS.mkdir(parents=True, exist_ok=True)

def log(msg: str) -> None:
    ts = pd.Timestamp.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
    line = f"[{ts}] [BT9] {msg}"
    print(line)
    with open(LOGS / "sprint9_backtest.log", "a", encoding="utf-8") as fh:
        fh.write(line + "\n")

@dataclass
class Metrics:
    pf: float
    trades: int
    winrate: float
    avg_trade: float
    sharpe: float
    maxdd: float
    cagr: float

def load_orders() -> pd.DataFrame:
    path = OUT / "orders.csv"
    if not path.exists():
        raise FileNotFoundError(f"orders.csv not found: {path}")
    df = pd.read_csv(path)
    df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True).dt.tz_convert(None)
    df["side"] = df["side"].astype(str).str.upper()
    df["qty_filled"] = pd.to_numeric(df["qty_filled"], errors="coerce").fillna(0).astype(float)
    df = df[df["qty_filled"] > 0]
    df = df.sort_values(["timestamp", "symbol"]).reset_index(drop=True)
    return df

def load_prices(freq: str) -> pd.DataFrame:
    path = FEAT / f"regime_{freq}.parquet"
    if not path.exists():
        raise FileNotFoundError(f"features not found: {path}")
    px = pd.read_parquet(path, columns=["timestamp", "symbol", "close"]).rename(columns={"close": "px"})
    px["timestamp"] = pd.to_datetime(px["timestamp"], utc=True).dt.tz_convert(None)
    return px.sort_values(["symbol", "timestamp"]).reset_index(drop=True)

def _side_to_sign(side: str) -> int:
    return 1 if side == "BUY" else -1

def run_backtest(freq: str) -> tuple[pd.DataFrame, Metrics, Metrics]:
    orders = load_orders()
    prices = load_prices(freq)

    events = orders[["timestamp", "symbol", "side", "qty_filled", "px_exec", "px_ref", "commission"]].copy()
    events["sign"] = events["side"].map(_side_to_sign).astype(int)

    results = []
    for sym, px in prices.groupby("symbol"):
        px = px.copy()
        ev = events[events["symbol"] == sym].sort_values("timestamp")
        cash = 0.0
        pos = 0.0
        cash_nc = 0.0
        pos_nc = 0.0
        ev_idx = 0
        eq_rows = []
        for ts, price in px[["timestamp", "px"]].itertuples(index=False):
            while ev_idx < len(ev) and ev.iloc[ev_idx]["timestamp"] <= ts:
                e = ev.iloc[ev_idx]
                q = float(e["qty_filled"]) * float(e["sign"])
                cash -= q * float(e["px_exec"])
                cash -= float(e["commission"])
                pos += q
                cash_nc -= q * float(e["px_ref"])
                pos_nc += q
                ev_idx += 1
            eq = cash + pos * price
            eq_nc = cash_nc + pos_nc * price
            eq_rows.append((ts, sym, pos, cash, eq, pos_nc, cash_nc, eq_nc))
        sym_df = pd.DataFrame(
            eq_rows,
            columns=["timestamp", "symbol", "pos", "cash", "equity", "pos_nocost", "cash_nocost", "equity_nocost"]
        )
        results.append(sym_df)

    curve = pd.concat(results, ignore_index=True)
    agg = curve.groupby("timestamp").agg({"equity": "sum", "equity_nocost": "sum"}).reset_index()

    def _metrics(equity: pd.Series) -> Metrics:
        pnl = equity.diff().fillna(0.0)
        pnl_pos = pnl[pnl > 0].sum()
        pnl_neg = -pnl[pnl < 0].sum()
        pf = float(pnl_pos / pnl_neg) if pnl_neg > 0 else np.nan
        trades = int((pnl != 0).sum())
        winrate = float((pnl > 0).mean()) if trades > 0 else np.nan
        avg_trade = float(pnl.mean()) if trades > 0 else np.nan
        denom = np.maximum(1.0, equity.abs().rolling(20, min_periods=1).mean())
        ret = (pnl / denom).replace([np.inf, -np.inf], np.nan).dropna()
        sharpe = float(np.sqrt(252 * 78) * ret.mean() / (ret.std() + 1e-12)) if len(ret) > 1 else np.nan
        roll_max = equity.cummax()
        maxdd = float((equity - roll_max).min())
        # Days span from equity index (robust)
        try:
            idx = pd.to_datetime(equity.index)
            days = max(int((idx[-1] - idx[0]).days), 1)
        except Exception:
            days = 1
        start = float(equity.iloc[0])
        end = float(equity.iloc[-1])
        cagr = np.nan if abs(start) < 1e-6 else float(((end / max(start, 1e-9)) ** (365.0 / days)) - 1.0)
        return Metrics(pf, trades, winrate, avg_trade, sharpe, maxdd, cagr)

    agg = agg.set_index("timestamp")
    m_cost = _metrics(agg["equity"])
    m_noc = _metrics(agg["equity_nocost"])
    return agg.reset_index(), m_cost, m_noc

def write_report(curve: pd.DataFrame, m_cost: Metrics, m_noc: Metrics, freq: str) -> None:
    (OUT / f"equity_curve_{freq}.csv").write_text(
        curve.to_csv(index=False), encoding="utf-8"
    )
    lines = [
        "# Performance Report",
        "",
        f"**Frequency**: {freq}",
        "",
        "## With Costs",
        f"- PF: {m_cost.pf:.2f}",
        f"- Trades: {m_cost.trades}",
        f"- Winrate: {m_cost.winrate:.2%}",
        f"- Avg Trade: {m_cost.avg_trade:.4f}",
        f"- Sharpe: {m_cost.sharpe:.2f}",
        f"- Max Drawdown: {m_cost.maxdd:.2f}",
        f"- CAGR: {m_cost.cagr:.2%}",
        "",
        "## No Costs (Benchmark)",
        f"- PF: {m_noc.pf:.2f}",
        f"- Trades: {m_noc.trades}",
        f"- Winrate: {m_noc.winrate:.2%}",
        f"- Avg Trade: {m_noc.avg_trade:.4f}",
        f"- Sharpe: {m_noc.sharpe:.2f}",
        f"- Max Drawdown: {m_noc.maxdd:.2f}",
        f"- CAGR: {m_noc.cagr:.2%}",
    ]
    (OUT / "performance_report.md").write_text("\n".join(lines), encoding="utf-8")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--freq", default="5min", choices=["1min", "5min", "15min"])
    args = ap.parse_args()
    log(f"START Backtest | freq={args.freq}")
    curve, m_cost, m_noc = run_backtest(args.freq)
    write_report(curve, m_cost, m_noc, args.freq)
    log(f"[OK] written: output/equity_curve_{args.freq}.csv")
    log("[OK] written: output/performance_report.md")
    log("DONE Backtest")

if __name__ == "__main__":
    main()
