#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Sprint 10 – Portfolio Wiring with Start Capital & Exposure (CLEAN)
- Capital-based portfolio on regime features
- Equal-weight exposure across active symbols
- Next-bar-open execution with simple cost model
- Outputs: portfolio_trades.csv, portfolio_equity_<freq>.csv, portfolio_report.md
"""
from __future__ import annotations
import argparse
from dataclasses import dataclass
from pathlib import Path
import numpy as np
import pandas as pd

ROOT = Path(__file__).resolve().parents[1]
OUT = ROOT / "output"
FEAT = OUT / "features"
LOGS = ROOT / "logs"
OUT.mkdir(parents=True, exist_ok=True)
LOGS.mkdir(parents=True, exist_ok=True)


def log(msg: str) -> None:
    ts = pd.Timestamp.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
    line = f"[{ts}] [PF10] {msg}"
    print(line)
    with open(LOGS / "sprint10_portfolio.log", "a", encoding="utf-8") as fh:
        fh.write(line + "\n")


def load_features(freq: str) -> pd.DataFrame:
    path = FEAT / f"regime_{freq}.parquet"
    if not path.exists():
        raise FileNotFoundError(f"features not found: {path}")
    df = pd.read_parquet(path)
    df["timestamp"] = pd.to_datetime(df["timestamp"], utc=True).dt.tz_convert(None)
    df["symbol"] = df["symbol"].astype(object).where(df["symbol"].notna(), "UNKNOWN")
    need = {"timestamp","symbol","open","close","trend_regime","vol_regime","liq_regime","spread_proxy"}
    miss = need - set(df.columns)
    if miss:
        raise ValueError(f"Missing columns in features: {sorted(miss)}")
    return df.sort_values(["symbol","timestamp"]).reset_index(drop=True)


def next_open(df: pd.DataFrame) -> pd.Series:
    col = "open" if "open" in df.columns else "close"
    return df.groupby("symbol")[col].shift(-1)


def build_trades(df: pd.DataFrame, exposure: float, start_capital: float, spread_w: float, impact_w: float, commission_bps: float) -> pd.DataFrame:
    df = df.copy()
    df["reg"] = df["trend_regime"].fillna(0).astype(int)
    df["reg_sw"] = df.groupby("symbol")["reg"].diff().fillna(0).ne(0)
    df["open_next"] = next_open(df)

    # active symbols per timestamp (for equal-weight)
    ts_sym = df.dropna(subset=["open_next"]).groupby("timestamp")["symbol"].nunique().rename("n_active")
    df = df.merge(ts_sym, on="timestamp", how="left")

    trades = df[df["reg_sw"] & df["open_next"].notna()].copy()
    trades = trades[["timestamp","symbol","reg","open_next","spread_proxy","vol_regime","liq_regime","n_active"]]
    trades.rename(columns={"open_next":"px_ref"}, inplace=True)
    trades["side"] = trades["reg"].map({-1:"SELL",0:"FLAT",1:"BUY"})

    trades["spread_w"] = float(spread_w)
    trades["impact_w"] = float(impact_w)
    trades["commission_bps"] = float(commission_bps)
    trades["exposure"] = float(exposure)
    trades["start_capital"] = float(start_capital)
    return trades.sort_values(["timestamp","symbol"]).reset_index(drop=True)


def apply_costs(side: pd.Series, px_ref: pd.Series, spread_proxy: pd.Series, vol_regime: pd.Series, liq_regime: pd.Series, spread_w: float, impact_w: float, commission_bps: float) -> tuple[pd.Series, pd.Series]:
    half_spread = 0.5 * spread_w * spread_proxy.fillna(0.0005)
    impact = (0.0002 * impact_w * vol_regime.fillna(0)) + (0.0003 * impact_w * (1 - liq_regime.fillna(0)))
    slip = half_spread + impact
    signed = np.where(side.values == "BUY", +slip, -slip)
    px_exec = px_ref * (1.0 + signed)
    commission = commission_bps * 1e-4 * px_exec  # per unit; multiply by qty later
    return px_exec, commission


def simulate(df: pd.DataFrame, trades: pd.DataFrame, start_capital: float, exposure: float, max_leverage: float) -> tuple[pd.DataFrame, pd.DataFrame]:
    symbols = sorted(df["symbol"].unique())
    timeline = sorted(df["timestamp"].unique())

    cash = start_capital
    positions = {s: 0.0 for s in symbols}

    exec_rows = []
    eq_rows = []

    px_close = df.pivot(index="timestamp", columns="symbol", values="close").reindex(index=timeline, columns=symbols)

    trade_iter = trades.itertuples(index=False)
    current = next(trade_iter, None)

    for ts in timeline:
        # execute trades scheduled at this timestamp
        while current is not None and current.timestamp == ts:
            sym = current.symbol
            side = current.side
            px_ref = float(current.px_ref)
            px_exec, comm_unit = apply_costs(pd.Series([side]), pd.Series([px_ref]),
                                             pd.Series([current.spread_proxy]), pd.Series([current.vol_regime]), pd.Series([current.liq_regime]),
                                             current.spread_w, current.impact_w, current.commission_bps)
            px_exec = float(px_exec.iloc[0]); comm_unit = float(comm_unit.iloc[0])

            # equal-weight target across n_active symbols
            n_active = max(int(current.n_active), 1)
            # current portfolio equity (mark-to-market on close price at ts)
            eq_now = cash + sum(positions[s] * float(px_close.loc[ts, s] or 0.0) for s in symbols)
            target_gross = exposure * eq_now
            per_sym_notional = target_gross / n_active
            target_shares = (per_sym_notional / px_exec) * (1 if side == "BUY" else -1)
            qty = target_shares - positions[sym]

            # simple leverage cap
            gross_before = sum(abs(positions[s] * float(px_close.loc[ts, s] or 0.0)) for s in symbols)
            gross_after = gross_before + abs(qty * px_exec)
            max_gross = max_leverage * max(eq_now, 1e-6)
            if gross_after > max_gross:
                scale = max(0.0, (max_gross - gross_before) / (abs(qty * px_exec) + 1e-12))
                qty *= scale

            trade_cost = qty * px_exec
            commission = abs(qty) * comm_unit
            cash -= trade_cost + commission
            positions[sym] += qty
            exec_rows.append((ts, sym, side, float(qty), float(px_exec), float(commission)))
            current = next(trade_iter, None)

        eq_val = cash + sum(positions[s] * float(px_close.loc[ts, s] or 0.0) for s in symbols)
        eq_rows.append((ts, float(cash), float(eq_val)))

    trades_df = pd.DataFrame(exec_rows, columns=["timestamp","symbol","side","qty","px_exec","commission"])
    equity_df = pd.DataFrame(eq_rows, columns=["timestamp","cash","equity"])
    return trades_df, equity_df


@dataclass
class Metrics:
    pf: float
    trades: int
    winrate: float
    avg_trade: float
    sharpe: float
    maxdd: float
    cagr: float


def compute_metrics(equity: pd.Series, trades_pnl: pd.Series) -> Metrics:
    pnl_pos = trades_pnl[trades_pnl > 0].sum()
    pnl_neg = -trades_pnl[trades_pnl < 0].sum()
    pf = float(pnl_pos / pnl_neg) if pnl_neg > 0 else np.nan
    trades = int((trades_pnl != 0).sum())
    winrate = float((trades_pnl > 0).mean()) if trades > 0 else np.nan
    avg_trade = float(trades_pnl.mean()) if trades > 0 else np.nan

    ret = equity.pct_change().replace([np.inf, -np.inf], np.nan).dropna()
    sharpe = float(np.sqrt(252 * 78) * ret.mean() / (ret.std() + 1e-12)) if len(ret) > 1 else np.nan
    roll_max = equity.cummax()
    maxdd = float(((equity - roll_max) / (roll_max + 1e-12)).min())
    days = max((equity.index[-1] - equity.index[0]).days, 1)
    cagr = float((equity.iloc[-1] / max(equity.iloc[0], 1e-6)) ** (365 / days) - 1.0)
    return Metrics(pf, trades, winrate, avg_trade, sharpe, maxdd, cagr)


def write_reports(trades: pd.DataFrame, equity: pd.DataFrame, freq: str, m: Metrics) -> None:
    trades.to_csv(OUT / "portfolio_trades.csv", index=False)
    equity.to_csv(OUT / f"portfolio_equity_{freq}.csv", index=False)
    lines = [
        "# Portfolio Report",
        "",
        f"**Frequency**: {freq}",
        "",
        f"- PF: {m.pf:.2f}",
        f"- Trades: {m.trades}",
        f"- Winrate: {m.winrate:.2%}",
        f"- Avg Trade (PnL): {m.avg_trade:.4f}",
        f"- Sharpe: {m.sharpe:.2f}",
        f"- Max Drawdown: {m.maxdd:.2%}",
        f"- CAGR: {m.cagr:.2%}",
    ]
    (OUT / "portfolio_report.md").write_text("\n".join(lines), encoding="utf-8")


def main():
    ap = argparse.ArgumentParser(description="Sprint 10 – Portfolio Wiring")
    ap.add_argument("--freq", default="5min", choices=["1min","5min","15min"])
    ap.add_argument("--start-capital", type=float, default=10_000.0)
    ap.add_argument("--exposure", type=float, default=1.0)
    ap.add_argument("--max-leverage", type=float, default=1.0)
    ap.add_argument("--commission-bps", type=float, default=0.5)
    ap.add_argument("--spread-w", type=float, default=1.0)
    ap.add_argument("--impact-w", type=float, default=1.0)
    args = ap.parse_args()

    log(f"START Portfolio | freq={args.freq} start_capital={args.start_capital} exp={args.exposure} lev={args.max_leverage}")
    df = load_features(args.freq)
    trades = build_trades(df, args.exposure, args.start_capital, args.spread_w, args.impact_w, args.commission_bps)
    trades_df, equity_df = simulate(df, trades, args.start_capital, args.exposure, args.max_leverage)

    # approximate trade PnL from equity diffs at trade timestamps
    eq_ts = equity_df.set_index("timestamp")["equity"]
    t_equity = eq_ts.reindex(trades_df["timestamp"]).ffill()
    trades_pnl = t_equity.diff().fillna(0.0)

    m = compute_metrics(equity_df.set_index("timestamp")["equity"], trades_pnl)
    write_reports(trades_df, equity_df, args.freq, m)
    log("[OK] written: output/portfolio_trades.csv")
    log(f"[OK] written: output/portfolio_equity_{args.freq}.csv")
    log("[OK] written: output/portfolio_report.md")
    log("DONE Portfolio")

if __name__ == "__main__":
    main()
